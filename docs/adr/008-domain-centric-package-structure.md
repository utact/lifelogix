# [ADR-008] 도메인 중심 모듈형 패키지 구조 채택

- **Status:** Adopted
- **Last Updated:** 2025-10-06

---

## Context (컨텍스트)

프로젝트 초기 `user` 도메인은 `controller`, `service`, `repository`, `domain` 등 기술 계층에 따라 패키지를 구성하는 전통적인 **'계층형 아키텍처 (Package by Layer)'로** 구현되었다.

그러나 `timeline` 도메인과 하위 기능들을 추가하는 과정에서, 이 구조가 프로젝트 확장 시 응집도가 떨어지고 유지보수가 어려워질 수 있다는 우려가 제기되었다. 예를 들어, `user` 관련 기능을 수정하기 위해서는 여러 패키지를 넘나들어야 했다. 이에 따라 프로젝트 전체의 패키지 구조 전략을 재검토하게 되었다.

### **고려된 대안 (Alternatives Considered)**

1.  **계층형 아키텍처 (Layered Architecture / Package by Layer)**
    - **설명**: 모든 컨트롤러는 `controller` 패키지에, 모든 서비스는 `service` 패키지에 모으는 방식.
    - **장점**: 구조가 단순하고 많은 개발자에게 익숙하다.
    - **단점**: 기능이 추가될수록 각 계층 패키지가 비대해지고, 특정 기능과 관련된 파일들이 물리적으로 분리되어 응집도가 낮아진다.

2.  **도메인 중심 모듈형 아키텍처 (Domain-Centric Architecture / Package by Feature)**
    - **설명**: `user`, `timeline` 등 비즈니스 도메인을 최상위 패키지로 구성하고, 각 도메인 패키지 내부에 필요한 계층(api, application, domain)을 두는 방식.
    - **장점**: 기능 단위로 코드가 캡슐화되어 응집도가 매우 높다. 새로운 기능을 추가하거나 기존 기능을 수정할 때 특정 모듈에만 집중할 수 있어 확장성과 유지보수성이 뛰어나다.
    - **단점**: 초기 설계에 더 많은 고민이 필요하며, 헥사고날 아키텍처 등 관련 설계 원칙에 대한 이해가 요구될 수 있다.

---

## Decision (결정)

프로젝트의 장기적인 확장성과 유지보수성을 최우선 가치로 판단하여, **'도메인 중심 모듈형 아키텍처 (Package by Feature)'를** 프로젝트 전체의 표준 패키지 구조로 채택한다.

각 도메인 모듈은 헥사고날 아키텍처 원칙을 따라 다음과 같은 내부 계층 구조와 규칙을 가진다.

### **내부 계층 구조 원칙 (Internal Layer Principles)**

-   **`domain` 패키지 (The Core 🧠)**
    -   **역할**: 비즈니스의 가장 핵심적인 규칙과 데이터를 담는, 애플리케이션의 심장.
    -   **구성요소**: `@Entity` 클래스, `@Repository` **인터페이스**.
    -   **핵심 원칙 (The Purity Rule)**: 이 패키지는 **'순수함(Pure)'을 유지**해야 한다. **절대로** 외부 기술이나 프레임워크(Spring Web, Security 등)에 의존해서는 안 된다. 오직 순수 비즈니스 로직과 데이터 구조만 존재해야 한다.

-   **`application` 패키지 (The Orchestrator 🎼)**
    -   **역할**: 실제 사용 사례(Use Case)를 실행하고 트랜잭션을 관리하는 응용 서비스 계층.
    -   **구성요소**: `@Service` 클래스.
    -   **핵심 원칙**: `domain` 계층의 엔티티와 레포지토리를 사용하여 비즈니스 흐름을 조율한다. **절대로** 웹 계층(HTTP Request/Response)을 직접 다루어서는 안 되며, DTO가 아닌 도메인 객체(`User`, `Category` 등)를 반환하는 것을 원칙으로 한다.

-   **`api` 패키지 (The Adapter 🔌)**
    -   **역할**: 외부 세계(HTTP 요청 등)와의 접점. 외부 요청을 내부 `application` 계층이 이해할 수 있는 형태로 변환하고, 그 결과를 다시 외부 형식(JSON 등)으로 변환하여 응답하는 **번역가** 역할.
    -   **구성요소**: `@RestController`, `DTO`.
    -   **핵심 원칙**: **절대로** 비즈니스 로직을 포함해서는 안 된다. 또한, `domain` 계층의 레포지토리를 직접 호출해서는 안 되며, 항상 `application` 서비스 계층을 통해서만 비즈니스 로직을 실행해야 한다.

### **의존성 규칙 (The Dependency Rule)**

이 아키텍처의 가장 중요한 규칙은 의존성의 방향이다. 의존성은 **항상 외부에서 내부로만** 향해야 한다.

**`api` → `application` → `domain`**

`domain` 계층은 그 어떤 외부 계층에도 의존하지 않으며, 이 규칙을 통해 비즈니스 로직의 안정성과 독립성을 보장한다.

### **최종 패키지 구조 예시**
```
com.lifelogix
├── user
│   ├── api
│   ├── application
│   └── domain
└── timeline
    ├── category
    │   └── domain
    └── ...
```

---

## Consequences (결과)

### 긍정적
- **높은 응집도와 모듈성**: 각 기능이 독립적인 모듈처럼 구성되어 코드의 이해와 수정이 용이해진다.
- **향상된 확장성**: 새로운 비즈니스 도메인이 추가될 때, 기존 코드에 미치는 영향을 최소화하며 독립적으로 개발할 수 있다.
- **명확한 아키텍처**: 프로젝트 전체에 일관된 구조적 규칙이 적용되어 개발자 간의 협업 효율성이 증대된다.

### 부정적 (수행 과제)
- **초기 리팩토링 비용**: 기존 `user` 도메인 패키지를 새로운 표준 구조에 맞게 리팩토링하는 작업이 필요하다.
- **학습 곡선**: 팀원들이 새로운 구조와 설계 원칙에 익숙해지는 시간이 필요할 수 있다.
# LifeLogix 백엔드 아키텍처 가이드

- **Version:** 1.0.0
- **Status:** Finalized
- **Last Updated:** 2025-10-09

이 문서는 LifeLogix 백엔드 시스템을 구성하는 핵심 기술 스택, 아키텍처 원칙, 그리고 그 과정에서 마주했던 주요 기술적 도전과 해결 기록을 종합적으로 담고 있습니다.

---

## 1. 기술 스택 및 선정 원칙

모든 기술 선택은 **Testability(테스트 용이성), Scalability(확장성), Stability(안정성), Productivity(생산성)** 4가지 핵심 원칙을 따릅니다.

| 의존성 | 핵심 역할 (Role) | 선택 이유 (Rationale) |
| :--- | :--- |:---|
| **Spring Web** | RESTful API 엔드포인트 구축 | 검증된 안정성과 방대한 생태계를 가진 산업 표준 웹 프레임워크입니다. |
| **Spring Data JPA** | 도메인 객체(Entity)와 DB 테이블 매핑 및 데이터 영속성 관리 | DDD의 `Repository` 패턴을 직관적으로 지원하며, 객체 중심의 데이터 접근을 가능하게 합니다. |
| **PostgreSQL Driver** | `local` 환경에서 PostgreSQL DB와의 통신 | 강력한 트랜잭션과 유연한 JSONB 타입을 지원하는 최적의 오픈소스 RDBMS입니다. |
| **H2 Database** | `test` 환경을 위한 인메모리(In-memory) DB | 빠르고 격리된 테스트 환경을 구축하여 TDD의 핵심 원칙을 지원합니다. |
| **Spring Security** | JWT 기반 인증(Authentication) 및 인가(Authorization) 구현 | API 엔드포인트를 안전하게 보호하는 가장 강력하고 표준적인 프레임워크입니다. |
| **OAuth2 Resource Server** | JWT 토큰 검증 및 사용자 정보 추출 | Spring Security 환경에서 토큰 기반 인증을 매우 간단하게 구현하도록 돕습니다. |
| **Lombok** | Boilerplate 코드 자동 생성 | 개발자가 도메인 로직의 본질에만 집중하도록 하여 TDD 효율을 극대화합니다. |
| **Validation** | DTO 레벨에서 데이터 유효성 검사 규칙 적용 | 서비스 로직 진입 전, 잘못된 데이터를 차단하는 Gatekeeper 역할을 합니다. |
| **Spring Boot DevTools**| 코드 변경 시 애플리케이션 자동 재시작 | TDD 사이클의 속도를 극적으로 단축시킵니다. |

---

## 2. 핵심 아키텍처 원칙

### 2.1. 패키지 구조 원칙: 도메인 중심 모듈형 아키텍처

프로젝트의 모든 패키지 구조는 **도메인 중심 모듈형 아키텍처(Domain-Centric Modular Architecture)를** 따릅니다. 이는 기능(Feature) 단위의 높은 응집도와 계층(Layer) 간의 명확한 책임 분리를 통해, 프로젝트의 장기적인 확장성과 유지보수성을 확보하는 것을 목표로 합니다.

상세한 계층 구조, 역할, 규칙, 의존성 원칙은 아래의 의사결정 문서를 참조해야 합니다.

-   **`ADR-008`: 도메인 중심 모듈형 패키지 구조 채택**
-   **`ADR-009`: API 계층 내부 패키지 구조 세분화**

### 2.2. 인증 철학: Stateless 원칙과 JWT

우리 서버는 클라이언트의 상태를 세션 등에 저장하지 않는 **완전한 무상태(Stateless)를** 유지하는 것을 원칙으로 합니다. 모든 요청은 JWT를 통해 그 자체로 인증에 필요한 모든 정보를 포함해야 합니다. 이는 서버의 확장성을 보장하고, 클라이언트와 서버 간의 의존성을 낮추기 위함입니다.

-   **JWT Payload 규칙**: 토큰의 주체(`sub`)는 반드시 사용자의 불변하는 `ID`(PK)를 사용합니다.
-   **Principal 해석**: `JwtAuthenticationConverter`를 커스텀하여, 컨트롤러가 `@AuthenticationPrincipal`을 통해 `Long` 타입의 사용자 ID를 안전하게 주입받도록 합니다.

### 2.3. 데이터 접근 원칙

-   **N+1 문제 예방**: 연관된 엔티티를 함께 조회할 때는 **반드시 Fetch Join (`JOIN FETCH`)을 사용하여 N+1 문제를 예방**합니다.
-   **복잡한 쿼리**: 여러 엔티티를 조인하는 등 복잡한 쿼리는 Spring Data JPA의 긴 쿼리 메서드 이름 대신, **`@Query` 어노테이션을 사용하여 JPQL을 직접 작성**하여 가독성과 유지보수성을 높입니다.

### 2.4. 테스트 코드 원칙

-   **계층별 테스트**: `@DataJpaTest`(Repository), `@ExtendWith(MockitoExtension.class)`(Service), `@SpringBootTest`(Controller)를 사용하여 각 계층의 역할을 명확히 분리하여 테스트합니다.
-   **가독성**: JUnit 5의 `@Nested`와 `@DisplayName`을 적극적으로 사용하여 테스트의 컨텍스트를 명시적으로 표현하고, BDD 스타일의 한글 메서드명을 통해 테스트 코드 자체가 명세서가 되도록 합니다.

---

## 3. 주요 기술적 도전과 해결 기록 (Deep Dive)

### 3.1. 미래를 위한 아키텍처 리팩토링

-   **문제 인식**: 프로젝트 초기의 단순 계층형 아키텍처는 기능 복잡도 증가 시 유지보수 비용이 급증할 위험이 있었습니다.
-   **해결 과정**: 개발 초기 단계임에도 '도메인 중심 모듈형 아키텍처'로 전체 구조를 리팩토링했습니다. (`ADR-008`, `ADR-009`)
-   **결론 및 성과**: 장기적인 유지보수성과 확장성의 기틀을 마련했습니다. 이를 통해 향후 비즈니스 로직이 복잡해지더라도 각 도메인이 독립적으로 발전할 수 있어, 기술 부채 발생을 억제하고 팀의 생산성을 유지하는 효과를 기대합니다.

### 3.2. 확장성을 고려한 Stateless 인증 설계

-   **문제 인식**: 안정성을 넘어, 향후 사용자 급증에 대비한 서버 증설(Scale-out)이 용이한 구조가 필요했습니다.
-   **해결 과정**: Stateless 아키텍처를 위해 JWT를 채택하고, Spring Security의 `JwtAuthenticationConverter`를 커스텀하여 인증 흐름을 최적화했습니다.
-   **결론 및 성과**: JWT 기반의 Stateless 아키텍처를 채택하여 서버의 수평적 확장에 용이한 기반을 마련했습니다. 특히 `JwtAuthenticationConverter` 커스터마이징을 통해, 토큰의 `sub` 클레임을 컨트롤러 단에서 타입-세이프한 `Long` 타입 ID로 즉시 주입받도록 구현하여 인증 로직의 Boilerplate 코드를 줄이고 코드 안정성과 가독성을 높였습니다.

### 3.3. 선제적 성능 최적화 (N+1 문제)

-   **문제 인식**: `GET /timeline` API는 복잡한 연관관계 조회로 인해 N+1 문제가 발생할 가능성이 높았습니다.
-   **해결 과정**: JPQL의 `JOIN FETCH`를 사용하여, 단 한 번의 쿼리로 관련된 모든 엔티티를 함께 가져오도록 데이터 접근 로직을 최적화했습니다.
-   **결론 및 성과**: `JOIN FETCH`를 통해 불필요한 추가 SQL 쿼리를 선제적으로 방지하고, 단일 쿼리로 연관된 모든 데이터를 조회하도록 최적화하여 API 응답 성능을 보장했습니다.

### 3.4. 데이터 모델링 (UX vs. 데이터 분석)

-   **문제 인식**: '카테고리' 기능에서 사용자 자율성과 데이터 분석의 일관성 확보라는 상충하는 요구사항이 있었습니다.
-   **해결 과정**: '시스템 카테고리'와 '커스텀 카테고리'를 나누고, 자기참조 관계를 활용한 '계층적 하이브리드 모델'을 설계했습니다. (`ADR-007`)
-   **결론 및 성과**: 설계된 하이브리드 모델은 현재의 유연한 UX를 만족시키면서도, 향후 데이터 기반의 비즈니스 의사결정에 필요한 데이터 정합성을 확보하는 확장성을 제공합니다.

### 3.5. 시스템 안정성 (중앙화된 예외 처리)

-   **문제 인식**: 개별적인 예외 처리는 API 에러 응답의 일관성을 해치고 유지보수성을 저하시킬 수 있습니다.
-   **해결 과정**: 모든 비즈니스 예외를 `ErrorCode` Enum에서 중앙 관리하고, `@RestControllerAdvice`를 통해 공통된 형식으로 처리하는 시스템을 설계했습니다. (`ADR-012`)
-   **결론 및 성과**: 예외 정책의 변경 및 추가가 용이해졌으며, 클라이언트가 예측 가능한 에러 처리를 할 수 있도록 하여 API의 전체적인 신뢰도를 높였습니다.

### 3.6. ORM과 객체-관계 불일치 문제 디버깅

-   **문제 인식**: 서비스 단위 테스트 중, JPA 엔티티를 `Stream`의 `groupingBy` 연산에 사용했을 때 예상과 다르게 동작하는 버그가 발생했습니다.
-   **해결 과정**: 원인이 객체의 식별성(Identity)과 동등성(Equality)의 차이임을 파악하고, 엔티티에 PK 기반의 `equals()`와 `hashCode()`를 `@EqualsAndHashCode(of = "id")`로 오버라이드하여 해결했습니다.
-   **결론 및 성과**: JPA 영속성 컨텍스트 환경에서 컬렉션 API 사용 시 발생할 수 있는 잠재적 버그를 해결했으며, 이는 팀 전체에 공유할 만한 좋은 기술적 선례가 됩니다.

### 3.7. 테스트 전략 (실용주의 vs. 코드 품질)

-   **문제 인식**: 일관성 없는 테스트 데이터 생성 방식으로 인해 테스트 코드의 품질이 저하될 우려가 있었습니다.
-   **해결 과정**: 테스트 데이터 생성 편의성과 프로덕션 코드의 안정성 사이에서 트레이드오프를 고려하여, 테스트용 생성자에 `@deprecated` 어노테이션을 붙이는 것으로 컨벤션을 수립했습니다. (`ADR-011`)
-   **결론 및 성과**: 테스트 작성의 생산성을 높이면서도, 프로덕션 코드에서의 의도치 않은 사용을 방지하는 균형점을 찾았습니다. 이는 프로젝트의 테스트 코드 작성 가이드라인으로 활용될 수 있습니다.